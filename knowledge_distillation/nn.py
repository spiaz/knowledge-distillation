# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03b_NN.ipynb (unless otherwise specified).

__all__ = ['create_nn', 'train_params', 'keras_model_and_classes_paths', 'save_keras_classifier', 'do_nothing',
           'load_keras_classifier']

# Cell
from .io import *

# Cell
import numpy as np
import pickle

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import Input
from tensorflow.keras import layers
from tensorflow.keras.layers import Dense, Dropout, BatchNormalization, Activation
from tensorflow.keras import regularizers, optimizers
from tensorflow.keras.wrappers.scikit_learn import KerasClassifier
from tensorflow.keras.callbacks import EarlyStopping, ModelCheckpoint
from tensorflow.keras.utils import to_categorical

# Cell
def create_nn(
    size_layer_1=64,
    size_layer_2=32,
    n_class=2,
    activation='relu',
    l2=0.1,
    dropout=0,
    learning_rate=0.01
):
    """Keras fully connected neural network."""
    nn = keras.Sequential()
    nn.add(Dense(size_layer_1, kernel_regularizer=regularizers.l2(l2)))
    nn.add(BatchNormalization())
    nn.add(Activation(activation))
    nn.add(Dropout(dropout))

    nn.add(Dense(size_layer_2, kernel_regularizer=regularizers.l2(l2)))
    nn.add(BatchNormalization())
    nn.add(Activation(activation))
    nn.add(Dropout(dropout))

    nn.add(Dense(n_class, activation='softmax'))

    loss = 'binary_crossentropy'
    if n_class > 2:
        loss = 'categorical_crossentropy'

    nn.compile(loss=loss,
               optimizer=optimizers.Adam(learning_rate=learning_rate),
               metrics=[
                   'accuracy',
#                    tf.keras.metrics.AUC()
               ]
              )
    return nn



# Cell

# es = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=20)
# mc = ModelCheckpoint('best_model.h5', monitor='val_accuracy', mode='max', verbose=1, save_best_only=True)

train_params = {
    "epochs": 50,
    "batch_size": 256,
    "validation_split":.3,
    "size_layer_1":64,
    "size_layer_2":32,
    "n_class":2
#     "callbacks": [es, mc]
}

# Cell

def keras_model_and_classes_paths(name, path=ASSETS_PATH):
    """Get the paths for a keras model and classes"""

    model_path = path / f'{name}.tf'
    classes_path = path / f'{name}_classes.pkl'
    return model_path, classes_path

def save_keras_classifier(model, name, path=ASSETS_PATH):
    """Save a Keras model to disk"""
    model_path, classes_path = keras_model_and_classes_paths(name)

    pickle.dump(model.classes_, open(classes_path,'wb'))
    model.model.save(model_path)


# Cell
def do_nothing():
    return

def load_keras_classifier(name, path=ASSETS_PATH):
    """Load a Keras model from disk, as KerasClassifier (sklearn wrapper)"""
    model_path, classes_path = keras_model_and_classes_paths(name)

    nn = KerasClassifier(build_fn=do_nothing)

    # load model and classes
    nn.model = keras.models.load_model(model_path)
    classes = pickle.load(open(classes_path, 'rb'))

    # required for sklearn to believe that the model is trained
    nn._estimator_type = "classifier"
    nn.classes_ = classes

    return nn
